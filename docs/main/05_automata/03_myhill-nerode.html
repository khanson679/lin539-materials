<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>mathcommands-preproc</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <!-- Include this in HTML headers to activate MathJax. -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<h1 id="the-myhill-nerode-theorem-automata-as-quotient-structures">The Myhill-Nerode Theorem: Automata as quotient structures</h1>
<p>Remember that a quotient structure provides a “compressed” view of a structure under an equivalence relation. Instead of individual elements of the original structure, the quotient structure only operates with the equivalence classes induced by the equivalence relation. One of the most intriguing results of formal language theory is that FSAs are quotient structures of regular string languages.</p>
<p>In order to see this, we first need a suitable equivalence relation: the <strong>right congruence relation</strong> <span class="math inline">\(\equiv_L\)</span> with respect to some string language <span class="math inline">\(L\)</span>. Let <span class="math inline">\(L\)</span> be some arbitrary set of strings over <span class="math inline">\(\Sigma\)</span>. Then <span class="math inline">\(u \equiv_L v\)</span> iff <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> have the same <strong>good continuations</strong> with respect to <span class="math inline">\(L\)</span>. That is to say, if we can add some string <span class="math inline">\(s\)</span> to <span class="math inline">\(u\)</span> and get a member of <span class="math inline">\(L\)</span>, then we can also add <span class="math inline">\(s\)</span> to <span class="math inline">\(v\)</span> and get a member of <span class="math inline">\(v\)</span> (and the other way round).</p>
<div class="example">
<p>Let <span class="math inline">\(L \mathrel{\mathop:}=(ab)^+\)</span>. Consider the string <span class="math inline">\(\mathit{aba}\)</span>. It is not a member of <span class="math inline">\(L\)</span>, but we can add a <span class="math inline">\(b\)</span> at the end, yielding <span class="math inline">\(\mathit{aba} \cdot\mathit{b} = \mathit{abab} \in L\)</span>. But there’s infinitely many other strings we could’ve added: <span class="math inline">\(\mathit{bab}\)</span>, <span class="math inline">\(\mathit{babab}\)</span>, and so on. These are the good continuations of <span class="math inline">\(\mathit{aba}\)</span> with respect to <span class="math inline">\(L\)</span>.</p>
<p>Now consider the string <span class="math inline">\(\mathit{ababa}\)</span>. Like <span class="math inline">\(\mathit{aba}\)</span>, it does not belong to <span class="math inline">\(L\)</span>, but we can add various strings to it to obtain a member of <span class="math inline">\(L\)</span>. But as you can verify for yourself, <span class="math inline">\(\mathit{aba}\)</span> and <span class="math inline">\(\mathit{ababa}\)</span> have exactly the same good continuations. For every string <span class="math inline">\(u \in \Sigma^*\)</span>, <span class="math inline">\(\mathit{abau}\)</span> is a well-formed string of <span class="math inline">\(L\)</span> iff <span class="math inline">\(\mathit{ababau}\)</span> is. Hence <span class="math inline">\(\mathit{aba}\)</span> and <span class="math inline">\(\mathit{ababa}\)</span> are right congruent: <span class="math inline">\(\mathit{aba} \equiv_L \mathit{ababa}\)</span>.</p>
</div>
<div class="exercise">
<p>Describe the good continuations of <span class="math inline">\(\mathit{ab}\)</span> with respect to <span class="math inline">\((ab)^+\)</span> and show that <span class="math inline">\(\mathit{ab} \equiv_L \mathit{abab}\)</span>.</p>
<p><strong>Caution:</strong> The empty string is a possible continuation, too.</p>
</div>
<div class="exercise">
<p>Just because two strings are right congruent with respect to some string language <span class="math inline">\(L\)</span> does not mean that they are right congruent with respect to some other string language <span class="math inline">\(L&#39;\)</span>. Suppose that <span class="math inline">\(L&#39;\)</span> is <span class="math inline">\(\mathit{ababc}(ab)^+\)</span>. Show that <span class="math inline">\(\mathit{ab}\)</span> and <span class="math inline">\(\mathit{abab}\)</span> are not right congruent with respect to <span class="math inline">\(L&#39;\)</span>.</p>
</div>
<p>It is fairly easy to see that <span class="math inline">\(\equiv_L\)</span> is an equivalence relation.</p>
<div class="exercise">
<p>Explain why! You’ll have to remember which properties a relation has to meet in order to be an equivalence relation. For each property, explain in intuitive terms why it holds.</p>
</div>
<p>Now consider the partition induced by <span class="math inline">\(\equiv_L\)</span>. That is to say, we group all the strings into equivalence classes such that the equivalence class <span class="math inline">\([u]\)</span> contains <span class="math inline">\(u\)</span> and all strings <span class="math inline">\(v\)</span> that are right congruent with <span class="math inline">\(u\)</span>.</p>
<div class="exercise">
<p>If <span class="math inline">\(u \equiv_L v\)</span>, then <span class="math inline">\([u] = [v]\)</span>. Explain why!</p>
</div>
<p>All these equivalence classes are connected by a relation <span class="math inline">\(\Delta\)</span>. Let <span class="math inline">\(\sigma\)</span> be some symbol of our alphabet <span class="math inline">\(\Sigma\)</span>. We say that <span class="math inline">\([x]\)</span> is <span class="math inline">\(\Delta\)</span>-related to <span class="math inline">\([y]\)</span> via <span class="math inline">\(\sigma\)</span> iff <span class="math inline">\([y] = [x \sigma]\)</span>.</p>
<div class="example">
<p>The equivalence class <span class="math inline">\([\mathit{ab}]\)</span> with respect to <span class="math inline">\(\equiv_L\)</span> contains <span class="math inline">\(\mathit{\varepsilon}\)</span>, <span class="math inline">\(\mathit{ab}\)</span>, <span class="math inline">\(\mathit{abab}\)</span>, and so on. That’s because <span class="math inline">\(L\)</span> is <span class="math inline">\((ab)^+\)</span> and all these strings have the same good continuations with respect to <span class="math inline">\(L\)</span>. The equivalence class <span class="math inline">\([\mathit{ab}]\)</span> is <span class="math inline">\(a\)</span>-related to <span class="math inline">\([\mathit{aba}] \mathrel{\mathop:}=\left \{ \mathit{a}, \mathit{aba}, \mathit{ababa}, \ldots \right \}\)</span>. In addition, <span class="math inline">\([\mathit{ab}]\)</span> is <span class="math inline">\(b\)</span>-related to <span class="math inline">\([\mathit{abb}]\)</span>, which contains all strings that are not members of <span class="math inline">\(L\)</span> (i.e. <span class="math inline">\(\Sigma^* - L\)</span>).</p>
</div>
<p>The equivalence classes, combined with <span class="math inline">\(\Delta\)</span>, form a quotient structure: instead of adding a symbol <span class="math inline">\(a\)</span> to a string <span class="math inline">\(s\)</span> and then computing the good continuations of <span class="math inline">\(s \cdot a\)</span>, one can immediately move from <span class="math inline">\([s]\)</span> to <span class="math inline">\([sa]\)</span>.</p>
<p>Now here’s the cool part: The deterministic FSA for some regular language <span class="math inline">\(L\)</span> is a quotient structure in this sense. The states of the automaton correspond to the equivalence classes in the quotient structure. Two strings are in the same equivalence class if they lead to the same state. For any given state/equivalence class the set of good continuations corresponds to the set of paths that lead from the state to a final state. And <span class="math inline">\(\Delta\)</span> above is exactly the same as the transition relation <span class="math inline">\(\Delta\)</span> of the FSA. So deterministic FSAs are quotient structures, with states as the counterpart of equivalence classes of strings.</p>
<div class="example">
<p>Consider once more the string language <span class="math inline">\(L \mathrel{\mathop:}=(ab)^+\)</span>. The right congruence relation <span class="math inline">\(\equiv_L\)</span> partitions the set <span class="math inline">\(\Sigma^*\)</span> of all strings into four equivalence classes:</p>
<ul>
<li><span class="math inline">\([\varepsilon]\)</span> consists only of the empty string, which can be continued with any member of <span class="math inline">\((ab)^+\)</span>,</li>
<li><span class="math inline">\([a] \mathrel{\mathop:}=\left \{ a, aba, ababa \right \}\)</span> contains all strings that can be continued with <span class="math inline">\(b\)</span>, <span class="math inline">\(bab\)</span>, <span class="math inline">\(babab\)</span>, and so on,</li>
<li><span class="math inline">\([ab] \mathrel{\mathop:}=\left \{ ab, abab, ababab \right \}\)</span> contains all strings that can be continued with the empty string or any member of <span class="math inline">\((ab)^+\)</span>,</li>
<li><span class="math inline">\([b]\)</span> contains strings such as <span class="math inline">\(b\)</span>, <span class="math inline">\(abb\)</span>, <span class="math inline">\(abababaa\)</span>, i.e. any string that has no good continuations at all.</li>
</ul>
<p>The automaton for <span class="math inline">\((ab)^+\)</span> is shown below, with an explicit sink state for ill-formed strings.</p>
<p><img src="abplus.svg" alt="abplus.svg" /></p>
<p>We can rename the states to highlight their connection to the equivalence classes above.</p>
<p><img src="abplus_quotientclasses.svg" alt="abplus_quotientclasses.svg" /></p>
</div>
<div class="exercise">
<p>Describe the partition induced by <span class="math inline">\(\equiv_L\)</span> if <span class="math inline">\(L \mathrel{\mathop:}=(ab)^*\)</span> — that is to say, <span class="math inline">\(L\)</span> contains the empty string, every member of <span class="math inline">\((ab)^+\)</span>, and nothing else. Then draw the automaton for <span class="math inline">\(L\)</span>. Which state corresponds to which equivalence class?</p>
</div>
<p>The connection between congruence classes and states of an FSA isn’t just a nice mathematical curiosity. It is the foundation of the famous Myhill-Nerode theorem.</p>
<div class="theorem">
<p>A string language <span class="math inline">\(L\)</span> is regular iff <span class="math inline">\(\equiv_L\)</span> has finite index.</p>
</div>
<p>For an equivalence relation to have <strong>finite index</strong> means that it induces only finitely many equivalence classes. So the Myhill-Nerode theorem states that a string language is regular iff its quotient structure under <span class="math inline">\(\equiv_L\)</span> has only finitely many equivalence classes. But remember, these equivalence classes correspond to what we represent as states in an FSA. We already know that a language is regular iff it is recognized by an FSA, and FSAs only have finitely many states, i.e. equivalence classes. This is the connection exploited by the Myhill Nerode theorem.</p>
<p>Let’s look at it step by step. If a language is regular, then it must be recognized by some FSA. If so, then <span class="math inline">\(\equiv_L\)</span> induces only finitely many equivalence classes. Here’s why this must be the case: consider two arbitrary strings <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> of <span class="math inline">\(\Sigma^*\)</span>. We will look at how some arbitrary deterministic FSA <span class="math inline">\(A\)</span> behaves with respect to those strings. To simplify things, we will assume that <span class="math inline">\(A\)</span> has a sink. As adding a sink is trivial, this simplifying assumption does not endanger the validity of the argument.</p>
<p>Suppose that the runs <span class="math inline">\(r(s)\)</span> and <span class="math inline">\(r(t)\)</span> of <span class="math inline">\(A\)</span> over <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> end in the same state <span class="math inline">\(q\)</span>. Now if <span class="math inline">\(u\)</span> is a good continuation of <span class="math inline">\(s\)</span> with respect to <span class="math inline">\(L\)</span>, then there must be some path from <span class="math inline">\(q\)</span> to a final state. But then this path is also available for <span class="math inline">\(t\)</span>, because <span class="math inline">\(t\)</span> also ends in <span class="math inline">\(q\)</span>. Hence <span class="math inline">\(u\)</span> must also be a good continuation of <span class="math inline">\(t\)</span>. Therefore any two strings whose run ends in the same state have the same good continuations, and whenever <span class="math inline">\(r(s)\)</span> and <span class="math inline">\(r(t)\)</span> end in the same state it must be the case that <span class="math inline">\(r \equiv_L t\)</span>.</p>
<p>Since we added a sink state to <span class="math inline">\(A\)</span>, every run of <span class="math inline">\(A\)</span> over a <span class="math inline">\(\Sigma\)</span>-string must end in some state. Hence we can partition <span class="math inline">\(\Sigma^*\)</span> such that <span class="math inline">\(s \equiv_A t\)</span> iff <span class="math inline">\(r(s)\)</span> and <span class="math inline">\(r(t)\)</span> end in the same state. But since <span class="math inline">\(A\)</span> has only finitely many states, there can be only finitely many equivalence classes. And we know from our previous observations that <span class="math inline">\(s \equiv_A t\)</span> implies <span class="math inline">\(s \equiv_L t\)</span>. So the fact that <span class="math inline">\(\equiv_A\)</span> has finite index implies that <span class="math inline">\(\equiv_L\)</span> has finite index. This proves one direction of the Myhill-Nerode theorem: if a language <span class="math inline">\(L\)</span> is regular, then <span class="math inline">\(\equiv_L\)</span> has finite index.</p>
<p>The same reasoning can be applied in the other direction to show that whenever <span class="math inline">\(\equiv_L\)</span> has finite index, once can construct an FSA from <span class="math inline">\(\equiv_L\)</span> that recognizes a string <span class="math inline">\(s\)</span> iff <span class="math inline">\(s \in L\)</span>.</p>
<p>And here’s why this result is important: it allows us to show that some string languages are not regular.</p>
<div class="example">
<p>Consider the string language <span class="math inline">\(a^n b^n\)</span>. The good continuations of <span class="math inline">\(a\)</span> are <span class="math inline">\(b\)</span>, <span class="math inline">\(abb\)</span>, <span class="math inline">\(aabbb\)</span>, and so on, i.e. <span class="math inline">\(a^n b^{n+1}\)</span>. The good continuations of <span class="math inline">\(aa\)</span>, on the other hand, are <span class="math inline">\(bb\)</span>, <span class="math inline">\(abbb\)</span>, <span class="math inline">\(aabbbb\)</span>, i.e. <span class="math inline">\(a^n b^{n+2}\)</span>. In general, the good continuations of <span class="math inline">\(a^n\)</span> are <span class="math inline">\(a^m b^{m+n}\)</span>. But this entails that <span class="math inline">\([a]\)</span>, <span class="math inline">\([aa]\)</span>, <span class="math inline">\([aaa]\)</span>, …, are all distinct equivalence classes. Every string of the form <span class="math inline">\(a^+\)</span> has its own equivalence class. But clearly there are inifnitely many such strings, which means that the quotient structure must contain infinitely many equivalence classes. In other words, <span class="math inline">\(\equiv_L\)</span> does not have finite index, wherefore <span class="math inline">\(L\)</span> is not regular.</p>
</div>
<div class="exercise">
<p>Use the Myhill-Nerode theorem to show that the following language is not regular if the alphabet <span class="math inline">\(\Sigma\)</span> contains at least two distinct symbols (e.g. <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>): <span class="math inline">\(\left \{ ww^R \mid w \in \Sigma^* \right \}\)</span>, where <span class="math inline">\(w^R\)</span> is the reverse of <span class="math inline">\(w\)</span>. This language is known as the <strong>palindrome language</strong>. The palindrome language contains strings such as <span class="math inline">\(abccba\)</span> or <span class="math inline">\(aaaa\)</span>, but not <span class="math inline">\(abcabc\)</span> or <span class="math inline">\(aaab\)</span>.</p>
</div>
<div class="exercise">
<p>Use the Myhill-Nerode theorem to show that the following language is not regular if the alphabet <span class="math inline">\(\Sigma\)</span> contains at least two distinct symbols (e.g. <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>): <span class="math inline">\(\left \{ ww \mid w \in \Sigma^* \right \}\)</span>. This language is known as the <strong>copy language</strong>. The copy language contains strings like <span class="math inline">\(abab\)</span>, <span class="math inline">\(aaaa\)</span>, or <span class="math inline">\(abbababbab\)</span>, but not <span class="math inline">\(abba\)</span>, <span class="math inline">\(aabaa\)</span>, or <span class="math inline">\(baaaba\)</span>.</p>
</div>
<div class="exercise">
<p>Show that both the palindrome language and the copy language are regular if the alphabet contains only a single symbol, e.g. <span class="math inline">\(a\)</span>.</p>
</div>
<p>You might wonder why we need the Myhill Nerode theorem to show that a language is or isn’t regular. Isn’t it enough to just write down an FSA? If we can’t do that, then the language apparently isn’t regular. Well, you’re half-right. If we can write down an FSA, then the language is regular (assuming our FSA works correctly). But if we can’t write down an FSA, nothing much follows. Perhaps there is an FSA and we just haven’t found it yet. After all, there’s infinitely many FSAs, so there’s always the chance that the next FSA we try might be the right one. The Myhill-Nerode theorem acts as a safeguard here. We can use it to show quickly that a language is not regular, potentially saving us days or weeks in search of a working FSA that does not exist.</p>
</body>
</html>
