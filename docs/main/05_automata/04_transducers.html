<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>mathcommands-preproc</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/media/Data/kenneth/Git/lin539-materials/includes/web-custom.css" />
  <!-- Include this in HTML headers to activate MathJax. -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<h1 id="from-automata-to-transducers">From automata to transducers</h1>
<p>An automaton can be regarded as either a generator or a recognizer. The generator perspective asks what strings can be generated by following paths from initial states to final state. The recognizer perspective instead takes a string and asks whether it describes a path from an initial state to a final state. The two perspective seem different intuitively, but they are mathematically equivalent. A string language <span class="math inline">\(L\)</span> is generated by an automaton iff it is recognized by said automaton. The same is true for the <span class="math inline">\(n\)</span>-gram grammars we encountered earlier on: they can be regarded as generators of well-formed strings, or as recognizers that determine whether a given string is well-formed.</p>
<p>But not all problems in natural language are concerned with well-formedness in this narrow sense. For example, we might want to translate an underlying morphological representation like <em>car+PL</em> to the surface form <em>cars</em>. This is not a matter of well-formedness. Our primary concern is not whether the underlying form is licit, but just what its corresponding surface form should be. It’s not about string languages, but <strong>string relations</strong>. For these cases, an automaton is not the right tool. Instead, we need <strong>transducers</strong>.</p>
<h2 id="transducer-automaton-with-output">Transducer = automaton with output</h2>
<p>A finite-state transducer (FST) looks exactly like an FSA except that arcs are now labeled with pairs of symbols. The first one still determines how the transducer switches between states as it moves through the string. The second symbol, on the other hand, is emitted by the transducer. This allows the transducer to gradually produce an output string as it moves through the input string.</p>
<div class="example">
<p>The transducer below keeps all <span class="math inline">\(a\)</span>s as <span class="math inline">\(b\)</span>s while keeping <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> the same.</p>
<p><img src="fst_a2b.svg" alt="fst_a2b.svg" /></p>
<p>It gradually transforms <span class="math inline">\(acbbaa\)</span> one symbol after the other:</p>
<ul>
<li><span class="math inline">\(\mathbf{b}cbbaa\)</span></li>
<li><span class="math inline">\(b\mathbf{c}bbaa\)</span></li>
<li><span class="math inline">\(bc\mathbf{b}baa\)</span></li>
<li><span class="math inline">\(bcb\mathbf{b}aa\)</span></li>
<li><span class="math inline">\(bcbb\mathbf{b}a\)</span></li>
<li><span class="math inline">\(bcbba\mathbf{b}\)</span></li>
</ul>
</div>
<div class="exercise">
<p>Gradually rewrite <span class="math inline">\(aaaaba\)</span> in the fashion above.</p>
</div>
<div class="example">
<p>This transducer rewrites <span class="math inline">\(a\)</span> as <span class="math inline">\(b\)</span> if it immediately follows <span class="math inline">\(b\)</span> in the input.</p>
<p><img src="fst_aafterb.svg" alt="fst_aafterb.svg" /></p>
</div>
<p>In a transducer, both the input and the output component of an arc label may be the empty string.</p>
<div class="example">
<p>The transducer below can follow the <span class="math inline">\(\varepsilon\)</span>-arc to start rewriting <span class="math inline">\(a\)</span> as <span class="math inline">\(b\)</span>.</p>
<p><img src="fst_emptyarcs.svg" alt="fst_emptyarcs.svg" /></p>
<p>For example, <span class="math inline">\(aaaa\)</span> can be rewritten as <span class="math inline">\(aabb\)</span>, but not <span class="math inline">\(abba\)</span>.</p>
</div>
<div class="exercise">
<p>The transducer above produces multiple outputs for the input string <span class="math inline">\(aaaa\)</span>. List all of them.</p>
</div>
<p>In fact, the arcs of an FSA may also be labeled by the empty string. But in an FSA <span class="math inline">\(\varepsilon\)</span>-labeled edges can always be replaced by arcs that are labeled by some symbol of the alphabet. With FSTs, this is not the case: some transductions can only be defined by FSTs with <span class="math inline">\(\varepsilon\)</span> in the labels.</p>
<div class="example">
<p>Suppose an FSA contains an <span class="math inline">\(\varepsilon\)</span>-arc from state <span class="math inline">\(q_1\)</span> to state <span class="math inline">\(q_2\)</span>. Assume furthermore that <span class="math inline">\(q_2\)</span> only has an <span class="math inline">\(a\)</span>-arc to <span class="math inline">\(q_3\)</span>. Then one can also add an <span class="math inline">\(a\)</span>-arc between <span class="math inline">\(q_1\)</span> and <span class="math inline">\(q_3\)</span>. One every outgoing arc from <span class="math inline">\(q_2\)</span> has a counterpart leaving <span class="math inline">\(q_1\)</span>, the <span class="math inline">\(\varepsilon\)</span>-arc between <span class="math inline">\(q_1\)</span> and <span class="math inline">\(q_2\)</span> becomes redundant and can be removed.</p>
<p>This is exemplified below. The first automaton contains two <span class="math inline">\(\varepsilon\)</span>-arcs.</p>
<p><img src="fsa_emptyarcs_step1.svg" alt="fsa_emptyarcs_step1.svg" /></p>
<p>We first remove the second <span class="math inline">\(\varepsilon\)</span>-arc. Since we can go from <span class="math inline">\(3\)</span> to <span class="math inline">\(6\)</span> with an <span class="math inline">\(\varepsilon\)</span>-arc from <span class="math inline">\(3\)</span> to <span class="math inline">\(5\)</span> and a <span class="math inline">\(d\)</span>-arc from <span class="math inline">\(5\)</span> to <span class="math inline">\(6\)</span>, we add a <span class="math inline">\(d\)</span>-arc from <span class="math inline">\(3\)</span> to <span class="math inline">\(6\)</span>. We can also go from <span class="math inline">\(3\)</span> to <span class="math inline">\(5\)</span> with an <span class="math inline">\(\varepsilon\)</span>-arc and then loop there with an <span class="math inline">\(e\)</span>-arc, so we add an <span class="math inline">\(e\)</span>-arc from <span class="math inline">\(3\)</span> to <span class="math inline">\(5\)</span>. This takes care of all outgoing arcs that can be taken via the <span class="math inline">\(\varepsilon\)</span>-arc from <span class="math inline">\(3\)</span>, so we remove the latter.</p>
<p><img src="fsa_emptyarcs_step2.svg" alt="fsa_emptyarcs_step2.svg" /></p>
<p>We now proceed in the same way for the first <span class="math inline">\(\varepsilon\)</span>-arc, connecting <span class="math inline">\(1\)</span> directly to any state that can be reached by first taking the <span class="math inline">\(\varepsilon\)</span>-arc from <span class="math inline">\(1\)</span> to <span class="math inline">\(3\)</span>.</p>
<p><img src="fsa_emptyarcs_step3.svg" alt="fsa_emptyarcs_step3.svg" /></p>
<p>At this point, state <span class="math inline">\(3\)</span> becomes redundant because it cannot be reached. So we remove it, giving us the final, <span class="math inline">\(\varepsilon\)</span>-free FSA.</p>
<p><img src="fsa_emptyarcs_step4.svg" alt="fsa_emptyarcs_step4.svg" /></p>
</div>
<div class="example">
<p>The following FST uses an empty input label to randomly insert arbitrarily many <span class="math inline">\(b\)</span>s in a string of <span class="math inline">\(a\)</span>s.</p>
<p><img src="fst_randominsert.svg" alt="fst_randominsert.svg" /></p>
</div>
<div class="exercise">
<p>Without <span class="math inline">\(\varepsilon\)</span> as the input label, the number of <span class="math inline">\(b\)</span>s that could be inserted would be bound by the size of the input string. Explain why!</p>
</div>
<div class="example">
<p>The FST below uses an empty output label to delete all <span class="math inline">\(a\)</span>s in the input.</p>
<p><img src="fst_delete.svg" alt="fst_delete.svg" /></p>
<p>Deletion is impossible without <span class="math inline">\(\varepsilon\)</span> as the output label.</p>
</div>
<div class="exercise">
<p>Design an FST that</p>
<ul>
<li>takes as its input members of <span class="math inline">\(\left \{ a,b \right \}^*\)</span>, and</li>
<li>can insert an unbounded number of <span class="math inline">\(a\)</span>s after each <span class="math inline">\(b\)</span> in the input, and</li>
<li>deletes the first <span class="math inline">\(b\)</span> that occurs immediately after <span class="math inline">\(a\)</span> in the input.</li>
</ul>
</div>
<p>As you can see, FSTs look very similar to FSAs, but that does not mean that every result that holds for FSAs also holds for FSTs. Unfortunately, this result extends to two important properties of FSAs: determinizability, and closure under intersection. But let’s first focus on a few highly useful properties of FSTs.</p>
<h2 id="composition-closure">Composition closure</h2>
<p>Finite-state transductions are closed under composition. So if <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> are finite-state transductions, then so is <span class="math inline">\(f \circ g \mathrel{\mathop:}=\left \{  \left \langle a,c \right \rangle \mid \left \langle a,b \right \rangle \in f, \left \langle b,c \right \rangle \in g \right \}\)</span>. One can easily construct a transducer for the composition of two FSTs by modifying the basic idea behind the intersection construction for FSAs.</p>
<div class="example">
<p>Consider the two FSTs below. The first one rewrites each <span class="math inline">\(a\)</span> as <span class="math inline">\(b\)</span>, whereas the second one rewrites ever other <span class="math inline">\(b\)</span> as <span class="math inline">\(c\)</span>.</p>
<p><img src="fst_a2b.svg" alt="fst_a2b.svg" /></p>
<p><img src="fst_otherb2c.svg" alt="fst_otherb2c.svg" /></p>
<p>Suppose our input string is <span class="math inline">\(bacab\)</span>. Then the first transducer rewrites it to <span class="math inline">\(bbcbb\)</span>, which is then rewritten as <span class="math inline">\(bccbc\)</span> by the second one. This is also the result obtained by the transducer below.</p>
<p><img src="fst_intersection.svg" alt="fst_intersection.svg" /></p>
</div>
<div class="exercise">
<p>What is the output of <span class="math inline">\(bacab\)</span> if one applies the second transducer before the first?</p>
</div>
<p>Here’s the relevant steps for the construction. As with the intersection construction for FSA, each state is a pair that encodes which state the first and second transducer are in, respectively. The major change is how states are connected by arcs, and how these arcs are labeled.</p>
<p>Suppose the current state is <span class="math inline">\(\left \langle 0,1 \right \rangle\)</span> and we want to add an arc for the input symbol <span class="math inline">\(a\)</span>. Then we first check what happens in the first transducer when it is in state <span class="math inline">\(0\)</span> and sees an <span class="math inline">\(a\)</span>. In the example above, we rewrite <span class="math inline">\(a\)</span> as a <span class="math inline">\(b\)</span> and move to state <span class="math inline">\(0\)</span>. Next we check what happens in the second transducer. Since we’re looking at the complex state <span class="math inline">\(\left \langle 0,1 \right \rangle\)</span>, we have to look at state <span class="math inline">\(1\)</span> in the second transducer. But now comes the crucial change: since the first transducer has rewritten <span class="math inline">\(a\)</span> as <span class="math inline">\(b\)</span>, the second transducer is fed <span class="math inline">\(b\)</span> as input rather than <span class="math inline">\(a\)</span>. So we aren’t interested in the <span class="math inline">\(a\)</span>-arc of the second transducer, but the <span class="math inline">\(b\)</span>-arc. This arc takes us back to state <span class="math inline">\(0\)</span> while emitting an <span class="math inline">\(a\)</span> as output. Now we have everything we need to add the correct arc to the composition transducer: the arc takes us from <span class="math inline">\(\left \langle 0,1 \right \rangle\)</span> to <span class="math inline">\(\left \langle 0,0 \right \rangle\)</span>, and it is labeled <span class="math inline">\(a:a\)</span> as the input in the first transducer is <span class="math inline">\(a\)</span> and the output in the second transducer is also <span class="math inline">\(a\)</span>. So the basic idea is: look at the output symbol of first transducer, and use that as the input symbol for the second transducer.</p>
<p>One more important difference: whereas a state in the intersection automaton is final iff both components are final, a state of the composition transducer is final iff its second component is final.</p>
<div class="example">
<p>Consider the composition automaton from the previous example, now with simplified state names.</p>
<p><img src="fst_intersection_simplestates.svg" alt="fst_intersection_simplestates.svg" /></p>
<p>Suppose we compose this transducer with an FST that optionally rewrites the first <span class="math inline">\(a\)</span> it encounters as <span class="math inline">\(b\)</span> and adds an arbitrary number of <span class="math inline">\(d\)</span>s at the end of the output. It also rejects all inputs that do not end in <span class="math inline">\(cc\)</span>. For such inputs, no output is produced.</p>
<p><img src="fst_firsta_twocs.svg" alt="fst_firsta_twocs.svg" /></p>
<p>The composition construction yields the following transducer:</p>
<p><img src="fst_composition_large.svg" alt="fst_composition_large.svg" /></p>
</div>
<div class="exercise">
<ul>
<li>What output <span class="math inline">\(o\)</span> does the first transducer produce for <span class="math inline">\(ccaaabc\)</span>?</li>
<li>Does the second transducer accept <span class="math inline">\(o\)</span> as an input? If so, what output does it produce?</li>
<li>Verify that the composition transducer computes the same output for <span class="math inline">\(ccaaabca\)</span>.</li>
</ul>
</div>
<div class="exercise">
<ul>
<li>Construct a transducer <span class="math inline">\(\tau\)</span> that takes members of <span class="math inline">\(\left \{ a,b \right \}^*\)</span> and replaces every other <span class="math inline">\(a\)</span> by <span class="math inline">\(b\)</span>.</li>
<li>Construct a transducer <span class="math inline">\(\rho\)</span> that takes members of <span class="math inline">\(\left \{ a,b \right \}^*\)</span> and replaces every other <span class="math inline">\(b\)</span> by <span class="math inline">\(a\)</span>.</li>
<li>Construct a transducer that computes <span class="math inline">\(\tau \circ \rho\)</span>.</li>
<li>Construct a transducer that computes <span class="math inline">\(\rho \circ \tau\)</span>.</li>
</ul>
</div>
<div class="exercise">
<ul>
<li>Construct a transducer that takes members of <span class="math inline">\(\left \{ a,b \right \}^n\)</span>, <span class="math inline">\(n \geq 2\)</span>, as input and non-deterministically rewrites the first two symbols by members of <span class="math inline">\(a^+\)</span>.</li>
<li>Construct a transducer that takes members of <span class="math inline">\(\left \{ a,b \right \}^*\)</span> as input and rewrites the last symbol as <span class="math inline">\(b\)</span>, if it exists.</li>
<li>Construct the corresponding composition transducer.</li>
</ul>
</div>
<p>Composition is a very important property of FSTs. It allows you to define very complex rewriting procedures as a cascade of simple FSTs. At the very end, you can automatically compose the whole cascade into a single FST. Running just one FST is much faster. A cascade of <span class="math inline">\(n\)</span> FSTs has to process the input string <span class="math inline">\(n\)</span> times, a single FST only processes it once. The downside is that the composition FST can be very big and thus consumes a lot of memory. This is the same time-space trade-off we encountered with the intersection of FSAs.</p>
<h2 id="regularity-of-output">Regularity of output</h2>
<p>The output language of an FST is always regular. This is fairly easy to see: just drop the input components of each arc label, and the FST becomes an FSA. Since a language is regular iff it is generated by an FSA, this shows that an FST produces a regular output language.</p>
<p>But this argument only works if the FST is not restricted by what inputs we feed into it.</p>
<div class="example">
<p>Let <span class="math inline">\(\tau\)</span> be the FST that maps every string to itself. Dropping the input components shows that the FST generates <span class="math inline">\(\Sigma^*\)</span>. But now suppose that we only take input strings from <span class="math inline">\(a^n b^n\)</span>. Since <span class="math inline">\(\tau\)</span> maps every string to itself, the output language is <span class="math inline">\(a^n b^b \neq \Sigma^*\)</span>. We already know from the Myhill-Nerode theorem that <span class="math inline">\(a^n b^n\)</span> is not regular.</p>
</div>
<p>So the choice of input language can directly affect the complexity of the output language. Not too surprising. But FSTs are nonetheless well-behaved in a specific way: if the input language is regular, then so is the output language. That is to say, if the set of inputs is a regular language, then so is the set of outputs.</p>
<p>The argument for this is a bit more involved. It’s included here for future reference, but don’t worry if you can’t quite make heads or tails of it. The important point is that FSTs preserve regularity.</p>
<ol type="1">
<li>Dropping the input component from an FST eliminates all input restrictions. Thus it is the same as assuming that the input language for the FST is <span class="math inline">\(\Sigma^*\)</span>.</li>
<li>Given a regular language <span class="math inline">\(L\)</span>, the set <span class="math inline">\(\left \{  \left \langle s,s \right \rangle \mid s \in L \right \}\)</span> is a finite-state transduction <span class="math inline">\(\mathrm{id}_L\)</span>.</li>
<li>For every regular language <span class="math inline">\(L\)</span>, it holds that <span class="math inline">\(L = \mathrm{id}_L(\Sigma^*)\)</span> (where <span class="math inline">\(\mathrm{id}_L(\Sigma^*)\)</span> is the output language of <span class="math inline">\(\mathrm{id}_L\)</span> over input language <span class="math inline">\(\Sigma^*\)</span>).</li>
<li>Consequently, it holds for every FST <span class="math inline">\(\tau\)</span> that <span class="math inline">\(\tau(L) = \mathrm{id}_L \circ \tau(\Sigma*)\)</span>. So <span class="math inline">\(\tau(L)\)</span> is identical to the FSA that is obtained by dropping the input labels from <span class="math inline">\(\mathrm{id}_L \circ \tau\)</span>. Therefore <span class="math inline">\(\tau(L)\)</span> is regular.</li>
</ol>
<div class="exercise">
<p>Describe how one can construct an FST for <span class="math inline">\(\left \{  \left \langle s,s \right \rangle \mid s \in L \right \}\)</span> as long as <span class="math inline">\(L\)</span> is regular.</p>
</div>
<h2 id="closure-under-inverse">Closure under inverse</h2>
<p>FSTs enjoy one more property that is tremendously useful: the <strong>inverse</strong> of an FST is also an FST. So if we know that the mapping from inputs to outputs is a finite-state transduction, the corresponding mapping from outputs to inputs is to. All we have to do for this is switch the input and output components of the arc labels.</p>
<div class="example">
<p>to be done</p>
</div>
<p>Inversion makes it possible to use one and the same FST for generation and analysis.</p>
<div class="example">
<p>to be done</p>
</div>
<ol type="1">
<li>Connection between FSTs and SPE</li>
<li>Implications for phonology</li>
</ol>
</body>
</html>
