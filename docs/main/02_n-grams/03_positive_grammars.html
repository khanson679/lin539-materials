<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>mathcommands-preproc</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/style.css" />
  <!-- Include this in HTML headers to activate MathJax. -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<h1 id="positive-n-gram-grammars">Positive <span class="math inline">\(n\)</span>-gram grammars</h1>
<div class="prereqs">
<ul>
<li>basic math (factorial)</li>
</ul>
</div>
<p>We now have a simple model of phonotactics, i.e. what sequences of sounds may occur in the words of a natural language. According to this model, the phonotactic well-formedness of a word can be determined from the chunks that said word is built from. In a trigram model, for instance, a word is ill-formed iff it contains one or more illicit trigrams. We formalize this in terms of a negative <span class="math inline">\(n\)</span>-gram grammar, which is a finite set of illicit <span class="math inline">\(n\)</span>-grams.</p>
<div class="example">
<p>Suppose our alphabet, i.e. the set of available symbols, is <span class="math inline">\(\left \{ a,b,c \right \}\)</span>. Then the negative trigram grammar <span class="math inline">\(\left \{ \mathit{aac}, \mathit{abc}, \mathit{acc} \right \}\)</span> only permits strings where no symbol is directly sandwiched between <span class="math inline">\(a\)</span> and <span class="math inline">\(c\)</span>.</p>
</div>
<p>The model looks rather promising as it can handle a variety of phenomena that have been studied extensively by linguists: word-final devoicing, intervocalic voicing, local assimilation, and various stress rules.</p>
<div class="exercise">
<p>For each one of the following phenomena, write a negative <span class="math inline">\(n\)</span>-gram grammar that handles it correctly. For some of them, you have to rephrase the phenomenon as a phonotactic constraint first.</p>
<ul>
<li><strong>intervocalic voicing</strong>: voiceless fricatives (assume <em>s</em> and <em>f</em>) may not occur between vowels (assume <em>a</em>, <em>i</em>, <em>u</em>)</li>
<li><strong>local assimilation</strong>: <em>n</em> must be <em>m</em> before <em>b</em> or <em>p</em></li>
<li><strong>local dissimilation</strong>: <em>rVr</em> becomes <em>lVr</em>, where <em>V</em> is <em>a</em>, <em>i</em>, or <em>u</em></li>
<li><strong>penultimate stress</strong>: in words with at least two syllables, stress falls on the last but one syllable (assume that words are strings of stress syllables (<span class="math inline">\(\acute{\sigma}\)</span>) and unstressed syllables (<span class="math inline">\(\sigma\)</span>))</li>
</ul>
</div>
<p>Since the model seems to work well for phonotactics, it is tempting to expand it to other domains of language. But as we will see next, this reveals certain shortcomings of the negative grammar format.</p>
<h2 id="morphotactics">Morphotactics</h2>
<p>Just like phonotactics regulates the linear order of sounds in a word, <strong>morphotactics</strong> regulates the linear order of <strong>morphemes</strong>. Morphemes consist of multiple sounds and are the building blocks of words (linguists, please keep in mind that once again we won’t distinguish between morphemes, morphs, and allomorphs). For example, <em>denaturalization</em> is built from the morphemes <em>de-</em>, <em>nature</em>, <em>-al</em>, <em>-ize</em>, and <em>-ation</em>. Morphemes cannot be combined willy-nilly, they have to follow a specific order. In the case of <em>denaturalization</em>, no other order is possible. Even though the word is built up from 5 elements, which could be arranged in <span class="math inline">\(5! = 5 \times 4 \times 3 \times 2 \times 1 = 120\)</span> distinct ways, only one of them is actually allowed by English. So morphotactics defines a very tight rule system for how elements may be ordered in a word, much tighter than phonotactics, where individual sounds have more leeway as to where they occur in a word.</p>
<p>Let’s see if we can write a negative <span class="math inline">\(n\)</span>-gram grammar that allows for <em>denaturalization</em> but forbids all illicit orders, e.g. <em>naturedeationizal</em>. First, we have to pick the basic building blocks for the <span class="math inline">\(n\)</span>-grams. For phonotactics, we used <span class="math inline">\(n\)</span>-grams where each symbol is a sound, but this is too fine-grained for morphotactics. Instead, we will use <span class="math inline">\(n\)</span>-grams where each symbol is a morpheme. So <em>-ize -ation</em> is a bigram, not an 11-gram that consists of 8 letters, 2 hyphens, and 1 space.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>chunk <span class="op">=</span> <span class="st">&quot;-ize -ation&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> with characters as symbols: </span><span class="sc">{}</span><span class="st">-gram&quot;</span>.<span class="bu">format</span>(chunk, <span class="bu">len</span>(chunk)))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> with sounds as symbols: </span><span class="sc">{}</span><span class="st">-gram&quot;</span>.<span class="bu">format</span>(chunk, <span class="bu">len</span>(<span class="st">&quot;izaSon&quot;</span>)))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="bu">print</span>(<span class="st">&quot;</span><span class="sc">{}</span><span class="st"> with morphemes as symbols: </span><span class="sc">{}</span><span class="st">-gram&quot;</span>.<span class="bu">format</span>(chunk, <span class="bu">len</span>((<span class="st">&quot;-ize&quot;</span>, <span class="st">&quot;-ation&quot;</span>))))</span></code></pre></div>
<div class="exercise">
<p>For each one of the following <span class="math inline">\(n\)</span>-grams, say how large it is depending on what one chooses as the basic symbols that <span class="math inline">\(n\)</span>-grams are built from. Possible choices for building blocks are typed characters, morphemes, or words. Not all choice may be appropriate in each case.</p>
<ul>
<li><em>de-</em></li>
<li><em>mpi</em></li>
<li><em>John likes Mary</em></li>
</ul>
</div>
<p>With each morpheme as a separate symbol, it should be straight-forward to design a negative grammar to generate <em>de-nature-al-ize-ation</em> but none of the other orders. Let’s first write down the conditions in plain English:</p>
<ol type="1">
<li>start with <em>de-</em>,</li>
<li><em>de-</em> is followed by <em>nature</em>,</li>
<li><em>nature</em> is followed by <em>-al</em>,</li>
<li><em>-al</em> is followed by <em>-ize</em>,</li>
<li><em>-ize</em> is followed by <em>-ation</em>,</li>
<li>end with <em>-ation</em>.</li>
</ol>
<p>Easy peasy, so let’s write it down as a negative grammar. Here’s the list of the forbidden <span class="math inline">\(n\)</span>-grams that correspond to each one of the conditions.</p>
<ol type="1">
<li>start with <em>de-</em>
<ol type="1">
<li><em>⋊ $</em></li>
<li><em>⋊ nature</em></li>
<li><em>⋊ -al</em></li>
<li><em>⋊ -ize</em></li>
<li><em>⋊ -ation</em></li>
</ol></li>
<li><em>de-</em> is followed by <em>nature</em>
<ol type="1">
<li><em>de- $</em></li>
<li><em>de- de-</em></li>
<li><em>de- -al</em></li>
<li><em>de- ize</em></li>
<li><em>de -ation</em></li>
</ol></li>
<li><em>nature</em> is followed by <em>-al</em>
<ol type="1">
<li><em>nature ⋉</em></li>
<li><em>nature de-</em></li>
<li><em>nature nature</em></li>
<li><em>nature -ize</em></li>
<li><em>nature -ation</em></li>
</ol></li>
<li><em>-al</em> is followed by <em>-ize</em>
<ol type="1">
<li><em>-al ⋉</em></li>
<li><em>-al de-</em></li>
<li><em>-al nature</em></li>
<li><em>-al -al</em></li>
<li><em>-al -ation</em></li>
</ol></li>
<li><em>-ize</em> is followed by <em>-ation</em>
<ol type="1">
<li><em>-ize ⋉</em></li>
<li><em>-ize de-</em></li>
<li><em>-ize nature</em></li>
<li><em>-ize -al</em></li>
<li><em>-ize -ize</em></li>
</ol></li>
<li>end with <em>-ation</em>
<ol type="1">
<li><em>-ation de-</em></li>
<li><em>-ation nature</em></li>
<li><em>-ation -al</em></li>
<li><em>-ation ize</em></li>
<li><em>-ation -ation</em></li>
</ol></li>
</ol>
<p>Hmm, that didn’t turn out as succinctly as one might have hoped.</p>
<h2 id="from-negative-to-positive-grammars">From negative to positive grammars…</h2>
<p>The negative bigram grammar above is much larger than one would expect. Perhaps even more problematically, it does not clearly express the relevant generalizations. Intuitively, it would be much more appealing to list what combinations are allowed, rather than forbidden:</p>
<ol type="1">
<li>start with <em>de-</em>
<ol type="1">
<li><em>⋊ de-</em></li>
</ol></li>
<li><em>de-</em> is followed by <em>nature</em>
<ol type="1">
<li><em>de- nature</em></li>
</ol></li>
<li><em>nature</em> is followed by <em>-al</em>
<ol type="1">
<li><em>nature -al</em></li>
</ol></li>
<li><em>-al</em> is followed by <em>-ize</em>
<ol type="1">
<li><em>-al -ize</em></li>
</ol></li>
<li><em>-ize</em> is followed by <em>-ation</em>
<ol type="1">
<li><em>-ize -ation</em></li>
</ol></li>
<li>end with <em>-ation</em>
<ol type="1">
<li><em>-ation ⋉</em></li>
</ol></li>
</ol>
<p>This is a <strong>positive <span class="math inline">\(n\)</span>-gram grammar</strong>, where the <span class="math inline">\(n\)</span>-grams list what sequences are allowed, rather than forbidden.</p>
<div class="example">
<p>The list of bigrams above is <em>⋊ de-</em>, <em>de- nature</em>, <em>nature -al</em>, <em>-al -ize</em>, <em>-ize -ation</em>, <em>-ation ⋉</em>. If this is interpreted as positive bigram grammar, then only <em>denaturalization</em> is well-formed. A string like <em>nature -al -ize -ation -de</em> is illicit because it contains the bigram <em>-ation de-</em>, which is not part of the positive grammar and thus forbidden. If one adds <em>nature ⋉</em> to the grammar, then <em>nature</em> can also be generated.</p>
</div>
<p>In positive <span class="math inline">\(n\)</span>-gram grammars, all <span class="math inline">\(n\)</span>-grams must be of the same length to avoid inconsistencies. That’s because with a positive <span class="math inline">\(n\)</span>-gram grammar, a word is well-formed iff each one of its <span class="math inline">\(n\)</span>-grams is part of the grammar.</p>
<div class="example">
<p>Suppose we want to allow both <em>natural</em> and <em>denaturalization</em>, but not <em>denatural</em>. In order to allow the former, the grammar has to contain the bigrams <em>⋊ nature</em>, <em>nature -al</em>, and <em>-al ⋉</em>. But in combination with the bigrams from the previous example, this would also allow for <em>denatural</em>. Instead, then, one might try replacing <em>⋊ de-</em> with the 5-gram <em>⋊ de- nature -al -ize</em>, so that the grammar looks as follows:</p>
<ul>
<li><em>⋊ de- nature -al -ize</em></li>
<li><em>de- nature</em></li>
<li><em>nature -al</em></li>
<li><em>-al -ize</em></li>
<li><em>-ize -ation</em></li>
</ul>
<p>But then it is unclear how the grammar should be evaluated. If we look at all the 5-grams of <em>⋊ de- nature -al -ize -ation</em>, then only <em>⋊ de -nature -al -ize</em> is part of the grammar and the string is incorrectly ruled out. If we instead look at all the bigrams, then the word is ruled out because <em>⋊ de-</em> is no longer part of the grammar. Either way the mixing of bigrams and 5-grams causes inconsistencies.</p>
</div>
<p>Despite the requirement to stick with one fixed length of <span class="math inline">\(n\)</span>-grams, positive grammars can be much smaller than negative ones. But the opposite is also true, in particular for mixed negative grammars. It depends on the specific phenomenon.</p>
<div class="exercise">
<p>Write both a positive and a negative grammar that each allow only strings of the form <em>ab</em>, <em>abab</em>, <em>ababab</em>, <em>abababab</em>, and so on (assume that all symbols are either <em>a</em> or <em>b</em>). Is one of the two grammars more succinct or general than the other? What if the set of symbols is larger, e.g. <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em>?</p>
</div>
<div class="exercise">
<p>For each one of the following phenomena, write a positive <span class="math inline">\(n\)</span>-gram grammar that handles it correctly. For some of them, you have to rephrase the phenomenon as a phonotactic constraint first.</p>
<ul>
<li><strong>intervocalic voicing</strong>: voiceless fricatives (assume <em>s</em> and <em>f</em>) may not occur between vowels (assume <em>a</em>, <em>i</em>, <em>u</em>)</li>
<li><strong>local assimilation</strong>: <em>n</em> must be <em>m</em> before <em>b</em> or <em>p</em></li>
<li><strong>local disimilation</strong>: <em>rVr</em> becomes <em>lVr</em>, where <em>V</em> is <em>a</em>, <em>i</em>, or <em>u</em></li>
<li><strong>penultimate stress</strong>: in words with at least two syllables, stress falls on the last but one syllable (assume that words are strings of stress syllables (<span class="math inline">\(\acute{\sigma}\)</span>) and unstressed syllables (<span class="math inline">\(\sigma\)</span>))</li>
</ul>
<p>Once you’re done, contrast the positive grammars against the negative ones from an earlier exercise. Can you identify some general guidelines for when a positive grammar is preferable to a negative one?</p>
</div>
<h2 id="and-back-translating-between-positive-and-negative-grammars">…and back: Translating between positive and negative grammars</h2>
<p>We now have two different kinds of <span class="math inline">\(n\)</span>-gram grammars: positive grammars, and negative grammars. The latter fall into two subtypes, fixed and mixed, but as we have already proved those two are equivalent in the sense that one can freely translate between the two. The same is in fact true for positive and negative grammars.</p>
<p>The idea is very simple. Suppose that your alphabet (i.e. the set of symbols from which strings are built) contains only <em>a</em> and <em>b</em>. Then consider the language <span class="math inline">\((\mathit{aba})^+\)</span>, which contains <em>aba</em>, <em>ababa</em>, <em>abababa</em>, and so on. The negative grammar generating this language consists of</p>
<ol type="1">
<li><em>⋊⋉</em> (no string without any symbols),</li>
<li><em>⋊b</em> (don’t start with <em>b</em>),</li>
<li><em>aa</em> (don’t have <em>a</em> followed by <em>a</em>),</li>
<li><em>bb</em> (don’t have <em>b</em> followed by <em>b</em>),</li>
<li><em>b⋉</em> (don’t end with <em>b</em>).</li>
</ol>
<p>The positive grammar, on the other hand, contains</p>
<ol type="1">
<li><em>⋊a</em> (you may start with <em>a</em>),</li>
<li><em>ab</em> (<em>a</em> may be followed by <em>b</em>),</li>
<li><em>ba</em> (<em>b</em> may be followed by <em>a</em>),</li>
<li><em>a⋉</em> (you may end with <em>a</em>).</li>
</ol>
<p>Now compare this to the list of all possible bigrams over <em>a</em>, <em>b</em>, and <em>$</em>:</p>
<ol type="1">
<li><em>⋊⋉</em>,</li>
<li><em>⋊a</em>,</li>
<li><em>⋊b</em>,</li>
<li><em>a⋉</em>,</li>
<li><em>aa</em>,</li>
<li><em>ab</em>,</li>
<li><em>b⋉</em>,</li>
<li><em>ba</em>,</li>
<li><em>bb</em>.</li>
</ol>
<p>Notice anything? Each one of those bigrams is either in the negative grammar or in the positive one (but never in both). So in order to convert a positive grammar to a negative one, or the other way round, it suffices to first compute all possible <span class="math inline">\(n\)</span>-grams and then remove all those that are in the grammar that is to be converted to the opposite polarity.</p>
<div class="example">
<p>Suppose our alphabet contains only <em>a</em> and that the only well-formed string is <em>aa</em>. This would be the case if we have a positive trigram grammar containing:</p>
<ul>
<li><em>⋊⋊a</em></li>
<li><em>⋊aa</em></li>
<li><em>aa⋉</em></li>
<li><em>a⋉⋉</em></li>
</ul>
<p>The set of all possible (and useful) trigrams over the alphabet is as follows:</p>
<ul>
<li><em>⋊⋊a</em></li>
<li><em>⋊aa</em></li>
<li><em>aa⋉</em></li>
<li><em>a⋉⋉</em></li>
<li><em>⋊⋊⋊</em></li>
<li><em>⋊⋊⋉</em></li>
<li><em>⋊⋉⋉</em></li>
<li><em>⋉⋉⋉</em></li>
<li><em>⋊a⋉</em></li>
<li><em>aaa</em></li>
</ul>
<p>Removing all trigrams of the positive trigram grammar leaves us with the following list:</p>
<ul>
<li><em>⋊⋊⋊</em></li>
<li><em>⋊⋊⋉</em></li>
<li><em>⋊⋉⋉</em></li>
<li><em>⋉⋉⋉</em></li>
<li><em>⋊a⋉</em></li>
<li><em>aaa</em></li>
</ul>
<p>You can verify for yourself that a negative trigram grammar that contains those three trigrams (and no other <span class="math inline">\(n\)</span>-grams) can only generate <em>aa</em> over the alphabet <span class="math inline">\(\left \{ a \right \}\)</span>.</p>
</div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="im">from</span> itertools <span class="im">import</span> product</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">def</span> all_ngrams(alphabet, n):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;Build all n-grams over alphabet.&quot;&quot;&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="co"># for n = 0, we want the empty set rather than {&#39;&#39;}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">set</span>()</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>    <span class="cf">else</span>:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>        <span class="cf">return</span> <span class="bu">set</span>(<span class="st">&#39;&#39;</span>.join(ngram)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>                   <span class="cf">for</span> ngram <span class="kw">in</span> product(alphabet, repeat<span class="op">=</span>n))</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="kw">def</span> posneg_conversion(grammar, alphabet, n):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>    <span class="co">&quot;&quot;&quot;Convert between positive and negative n-gram grammars.</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="co">    </span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="co">    Arguments</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="co">    ---------</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span class="co">    grammar: set</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a><span class="co">        grammar that is to be converted</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a><span class="co">    alphabet: set</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a><span class="co">        alphabet for the grammar</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a><span class="co">    n: int</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a><span class="co">        length of n-grams</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>    <span class="cf">return</span> all_ngrams(alphabet, n) <span class="op">-</span> grammar</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>neg_gram <span class="op">=</span> <span class="bu">set</span>([<span class="st">&#39;aa&#39;</span>, <span class="st">&#39;ba&#39;</span>])</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true"></a>alphabet <span class="op">=</span> <span class="bu">set</span>([<span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, <span class="st">&#39;$&#39;</span>])</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true"></a>pos_gram <span class="op">=</span> posneg_conversion(neg_gram, alphabet, <span class="dv">2</span>)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true"></a><span class="bu">print</span>(<span class="st">&quot;The original grammar is:&quot;</span>)</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true"></a><span class="bu">print</span>(neg_gram)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true"></a><span class="bu">print</span>(<span class="st">&quot;The opposite polarity version is:&quot;</span>)</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true"></a><span class="bu">print</span>(pos_gram)</span></code></pre></div>
<div class="exercise">
<p>English allows for <em>nature</em>, <em>natural</em>, <em>naturalize</em>, <em>denaturalize</em>, <em>naturalization</em>, and <em>denaturalization</em>, but not <em>denature</em> or any of misordered forms like <em>naturizalation</em>. Write a grammar that generates all the well-formed forms but none of the ill-formed ones. It is up to you whether you want to use a positive or a negative grammar. If you use a negative grammar, it can be in the mixed format, with <span class="math inline">\(n\)</span>-grams of varying lengths.</p>
</div>
<h2 id="an-important-take-home-message">An important take-home message</h2>
<p>The next section will give a formal proof that this simple conversion strategy will always result in an equivalent grammar. By “equivalent” we mean that the two grammars generate exactly the same strings. But beyond pure math, there is an important insight here that will be with us for pretty much the rest of the course: one and the same thing can be specified in many different ways. Depending on one’s criteria, one way may be better than another. In some cases, a positive grammar may be smaller than a negative one. But for some phenomena it is the other way round, and negative grammar also has the advantage that they can be made more compact by using a mixed format instead of a fixed length for all <span class="math inline">\(n\)</span>-grams.</p>
<p>There’s many examples of this kind of interdefinability in mathematics. Logical formulas, for example, can be put into a normal form that is harder to read for humans but easier to implement for computers. So-called <strong>finite-state automata</strong> can be viewed as a special case of Boolean matrix multiplication (we’ll talk about this one in quite some detail). This may seem bewildering to the linguists among you. Linguists like to talk about <em>the</em> grammar, <em>the</em> feature system, <em>the</em> constraints of the grammar, as if those were concrete objects of a singular nature — like a chair is a chair is a chair. Linguistics is driven by the search for <em>the</em> correct description of linguistic knowledge. Linguists want the “source code” of the language program that runs in the human brain, not just any implementation that behaves the same. But this quest for <em>the</em> correct specification cannot work for abstract concepts, and all linguistic concepts are abstract. When dealing with abstract ideas, you want to be able to conceptualize them in as many distinct ways as possible. True understanding comes from the ability to describe one and the same thing in many different ways, each one with its unique advantages and its unique opportunities for new insights.</p>
<h2 id="recap">Recap</h2>
<ul>
<li>A positive <span class="math inline">\(n\)</span>-gram grammar is a finite list of allowed <span class="math inline">\(n\)</span>-grams.</li>
<li>Positive grammars can be converted to negative grammars, and the other way round.</li>
<li>Having multiple descriptions of the same thing is a boon, not a bane.</li>
</ul>
</body>
</html>
