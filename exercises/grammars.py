
from itertools import islice
import random

from util import substrings_len_k_of, language_sigma_k, language_sigma_up_to_k


class NGramGrammar:

    # left_edge_sym = '>'
    # right_edge_sym = '<'

    def __init__(self, alphabet, n, ngrams):
        if isinstance(alphabet, str):
            alphabet = set(alphabet)
        if isinstance(ngrams, list):
            ngrams = set(ngrams)
        for ngram in ngrams:
            if len(ngram) != n:
                raise ValueError(f"N-gram '{ngram}' not length {n}.")
            if not set(ngram).issubset(alphabet):
                raise ValueError(
                    f"N-gram '{ngram}' contains symbol not in alphabet.")
        self.alphabet = alphabet
        self.n = n
        self.ngrams = ngrams

    def match(self, string):
        raise NotImplementedError

    def gen_language(self, max_len, randomize=False):
        """
        Return generator over language of grammar including strings up to max_len.
        """
        sigma_k = language_sigma_up_to_k(self.alphabet, max_len)
        if randomize:
            random.shuffle(sigma_k)
        yield from (s for s in sigma_k if self.match(s))

    def gen_language_fast(self, max_len, randomize=False):
        raise NotImplementedError

    def gen_strings(self, max_len, n, randomize=False):
        """Return `n` strings up to `max_len` generated by the grammar."""
        return [s for s in islice(self.gen_language(max_len, randomize), n)]

    def gen_strings_fast(self, max_len, n, randomize=False):
        """Return `n` strings up to `max_len` generated by the grammar."""
        return [s for s in islice(self.gen_language_fast(max_len, randomize), n)]


class PosNGramGrammar(NGramGrammar):

    def __str__(self):
        return f"G(+): {self.ngrams}"

    def match(self, string):
        return all(ss in self.ngrams
                   for ss in substrings_len_k_of(string, self.n))

    def _possible_continuations(self, string):
        return [ng[-1] for ng in self.ngrams
                if string.endswith(ng[:-1])]

    def gen_language_fast(self, max_len, randomize=False):
        lang = [ng for ng in self.ngrams]
        for i in range(self.n, max_len + 1):
            additions = []
            for s in lang:
                if len(s) == i:
                    for suf in self._possible_continuations(s):
                        additions.append(s + suf)
            lang.extend(additions)
        if randomize:
            random.shuffle(lang)
        yield from lang

    # def gen_random_string(self, max_len):
    #     """
    #     max_len -- maximum length of string to generate
    #     """
    #     chars = random.choice(self.ngrams)
    #     while len(chars) < max_len:
    #         for ng in sorted(self.ngrams, key=lambda _: random.random()):
    #             if chars[self.n-2] == ng[:self.n-1]:
    #                 chars += ng[self.n:]
    #         else:
    #             # no more possible continuations
    #             break
    #     return chars


class NegNGramGrammar(NGramGrammar):

    def __str__(self):
        return f"G(â€“): {self.ngrams}"

    def match(self, string):
        return not any(s in self.ngrams
                       for s in substrings_len_k_of(string, self.n))

    def gen_language_fast(self, max_len, randomize=False):
        lang = [s for s in language_sigma_k(self.alphabet, self.n)
                if self.match(s)]
        # print(len(lang))
        prev_additions = lang
        for i in range(self.n, max_len + 1):
            additions = []
            for s in prev_additions:
                for c in self.alphabet:
                    newstr = s + c
                    if not newstr[-self.n:] in self.ngrams:
                        additions.append(newstr)
            # print(i, len(lang), len(additions))
            lang.extend(additions)
            prev_additions = additions
        if randomize:
            random.shuffle(lang)
        yield from lang
