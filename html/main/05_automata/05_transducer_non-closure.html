<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>mathcommands-preproc</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="/media/Data/kenneth/Git/lin539-materials/includes/web-custom.css" />
  <!-- Include this in HTML headers to activate MathJax. -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
</head>
<body>
<h1 id="fsa-properties-that-fsts-lack">FSA properties that FSTs lack</h1>
<h2 id="no-determinizability">No determinizability</h2>
<p>The powerset construction allows us to determinize non-deterministic FSAs. That is to say, for any non-deterministic FSA we can construct a fully equivalent, deterministic counterpart. The potential cost of determinization is a greatly increased state space. In some cases, the number of states does not grow at all, but in the worst case the blow-up is exponential (<span class="math inline">\(2^n\)</span> for a non-deterministic FSA with <span class="math inline">\(n\)</span> states). While that is not insignificant, at least we can always determinize arbitrary FSAs if we’re willing to pay the price. For some FSTs, that’s not even an option.</p>
<div class="example">
<p>Consider the FST below. It takes as its input strings of the form <span class="math inline">\(\left \{ a,b \right \}c^*\left \{ a,b \right \}\)</span> and maps them to <span class="math inline">\(d^+\)</span> or <span class="math inline">\(s^+\)</span> depending on whether the first symbol in the string matches the last symbol in the string. For instance, <span class="math inline">\(\mathit{acccb}\)</span> becomes <span class="math inline">\(\mathit{ddddd}\)</span>, but <span class="math inline">\(\mathit{accca}\)</span> becomes <span class="math inline">\(\mathit{sssss}\)</span>.</p>
<p>NFST</p>
<p>The FST is non-deterministic because the transducer has to guess right away whether the last symbol will be <span class="math inline">\(a\)</span> or <span class="math inline">\(b\)</span> in order to decide what to replace each symbol with. Since FSTs cannot look ahead arbitrarily far into the string, guessing is the only option. And this is exactly why the transducer cannot be determinized. A deterministic transducer does not get to guess. It can only do one thing when it sees the first symbol. Either it always rewrites it as <span class="math inline">\(d\)</span>, or it always rewrites it as <span class="math inline">\(s\)</span>. Neither option works in all cases.</p>
</div>
<div class="example">
<p>The FST below maps every string in <span class="math inline">\(a^*\)</span> to <span class="math inline">\(\left \{ b,c \right \}^*\)</span>.</p>
<p>NFST</p>
<p>This transducer is necessarily non-deterministic because one input can be mapped to multiple outputs. That’s impossible with a deterministic transducer. Deterministic FSTs compute functions (no input has more than one output), whereas the transducer above computes a relation.</p>
</div>
<p>The examples show that deterministic FSTs are much more limited than non-deterministic ones. Whenever one input has multiple outputs, one needs a non-deterministic transducer. For natural language, this mostly affects cases of optionality, such as whether <em>dream+PAST</em> should be <em>dreamed</em> or <em>dreamt</em>. But even when every input has at most one output, the transduction might still require a non-deterministic FSTs. This is usually the case when the transducer would have to make a decision based on a symbol that can be arbitrarily far to the right of the decision point. In these cases, non-determinism is needed to compensate for the lack of look-ahead.</p>
<h2 id="no-intersection-closure">No intersection closure</h2>
<p>In contrast to FSAs, FSTs also lack closure under intersection. The intersection of two finite-state transductions is not guaranteed to be a finite-state transduction.</p>
<div class="example">
<p>Consider the following two finite-state transductions: one rewrites every <span class="math inline">\(c^n\)</span> by <span class="math inline">\(a^* b^n\)</span>, the other one rewrites <span class="math inline">\(c^n\)</span> by <span class="math inline">\(a^n b^*\)</span>. Their intersection rewrites every <span class="math inline">\(c^n\)</span> by <span class="math inline">\(a^n b^n\)</span>. So the intersection maps the string language <span class="math inline">\(c^*\)</span> to the string language <span class="math inline">\(a^n b^n\)</span>. But we already know from the Myhill-Nerode theorem that <span class="math inline">\(a^n b^n\)</span> is not regular. Howver, <span class="math inline">\(c^*\)</span> is clearly regulary, and finite-state transductions preserve regularity. So if <span class="math inline">\(c^*\)</span> is regular, but <span class="math inline">\(a^n b^n\)</span> is not, then the transduction that maps the former to the latter cannot be finite-state. But this transduction was the intersection of two finite-state transductions, which show that closure under intersection does not hold.</p>
</div>
<div class="exercise">
<p>Use the same procedure to show that the intersection of multiple finite-state transduction can produce the output language <span class="math inline">\(a^n b^n c^n d^n e^n\)</span>.</p>
</div>
<h2 id="intersection-closure-for-equal-length-relations">Intersection closure for equal length relations</h2>
<p>There is one specific subcase of finite-state transductions that are closed under intersection. Those are the <strong>equal length</strong> relations. A finite-state transduction is an equal length relation iff an output always has the same length as its input. In other words, the FST only rewrites symbols in the input string, it does not add or remove any symbols. Equal length relations can be regarded as regular languages, and since regular languages are closed under intersection, equal length relations are too.</p>
<p>To see why equal length relations are regular languages, consider the simplest FST possible, the identity function. This transduction maps every string to itself and can be regarded as a set of pairs <span class="math inline">\(\left \langle s,s \right \rangle\)</span>, where <span class="math inline">\(s\)</span> is some string over <span class="math inline">\(\Sigma\)</span>. But since input and output have the same length, we may regard <span class="math inline">\(\left \langle s,s \right \rangle\)</span> as a single string of symbol pairs.</p>
<div class="example">
<p>The pair <span class="math inline">\(\left \langle aaba,aaba \right \rangle\)</span> relating an input string to an output string can be regarded as the single string <span class="math inline">\(\left \langle a,a \right \rangle \left \langle a,a \right \rangle \left \langle b,b \right \rangle \left \langle a,a \right \rangle\)</span>. So instead of a pair of strings over the alphabet <span class="math inline">\(\Sigma\)</span>, we have a single string over the alphabet <span class="math inline">\(\Sigma \times \Sigma\)</span>.</p>
</div>
<p>As long as an FST cannot delete or insert arbitrarily many symbols, it can be converted into an equal length relation by padding out inputs and outputs with a special symbol, e.g. 0.</p>
<div class="example">
<p>Consider an FST that simplifies consonant cluster such that <em>rdn</em> becomes <em>dn</em> (as is the case in Icelandic). Then a string like <em>bardn</em> becomes <em>badn</em>. Here the length of input and output are distinct, so the FST is not an equal length relation. However, we can opt to replace <em>r</em> by <em>0</em> instead of deleting it. Then the output for <em>bardn</em> is <em>ba0dn</em>. Now input and output have the same length.</p>
</div>
<div class="example">
<p>Suppose that another language optionally resolves <em>rdn</em> clusers by inserting an <em>e</em> between <em>d</em> and <em>n</em>. Then <em>bardn</em> becomes <em>barden</em>. Again input and output have distinct lengths. But we can use <em>bard0n</em> as a padded out version of the input instead. This input can be mapped to <em>barden</em> (cluster resolution) or <em>bard0n</em> (no resolution). Either way the output has the same length as the input.</p>
</div>
<p>Some formalisms such as two-level morphology make extensive use of such padding symbols to ensure that all transductions are equal length relations. While this grants intersection closure, it means that inputs and outputs are cluttered with padding symbols, which makes them harder to work with.</p>
</body>
</html>
